"""
    线程间通信方法:
        1 通信方法:
            线程间使用全局变量进行通信

        2 共享资源争夺
            共享资源:
                多个进程或者线程都可以操作操作的资源称为共享资源，对共享资源的操作代码段称为
                临界区
            影响:
                对共享资源的无序操作，可能会带来数据的混乱，或者操作错误。此时，往往需要同步互斥
                机制协调操作顺序

        3 同步互斥机制:
            同步:
                同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序
                执行操作（例如我们消息的收发，一收一发就是一种同步）
            互斥:
                互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其它进程线程
                就无法操作该资源，直到解锁后才能操作
                (例如打印机可以连接多个电脑，当两个电脑同时，发出打印指令时，就会形成一种抢占关系，
                一个电脑先抢占到，就会执行打印，并加锁，另一台电脑的指令就只能等待，所以互斥就可以
                看成是人为设置的一种阻塞，阻塞等待打印机执行完现有任务在接收新的指令)

    线程同步互斥方法:
        线程 Event:
            from threading import Event
            e = Event()  创建event对象

            e.wait([timeout])  阻塞等待e被set

            e.set()  设置e，使wait结束阻塞

            e.clear()  使e回到未被设置的状态

            e.is_set()  查看当前e是否被设置
"""


# event 线程互斥方法演示

from threading import Thread, Event

s = None  # 用于通信
e = Event()  # 生成时间对象


def yang():
    print("杨子荣前来拜山头")
    global s
    s = "天王盖地虎"
    e.set()  # 表示操作完共享资源


t = Thread(target=yang)
t.start()

# 这是主线程
# 结果不一定就是天王盖地虎，宝塔镇河妖...因为如果主线程先抢占到资源，先运行，那么此时s=None，
# 就会执行else的内容，反之，如果分支线程先运行，就执行if的内容，这就是争夺共享资源问题，有了同步互斥
# 机制就不会有这样的问题了
print("说对口令就是自己人")
e.wait()  # 阻塞等待，等s修改完成了在执行以下语句，现在就不会答错了
if s == '天王盖地虎':
    print("宝塔镇河妖")
    print("确认过眼神，你是对的人")

else:
    print("答错了")

t.join()
