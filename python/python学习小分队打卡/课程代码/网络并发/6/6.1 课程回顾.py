"""
    前情回顾:
        1 进程间通信:
            1 管道通信:
                Pipe()  p.send()  p.recv(),一次发送对应一次接收
            2 消息队列:
                queue()  q.get()  q.put(),
            3 共享内存:
                Value()单一值 Array()一组值,存入会覆盖上一次的内容
            4 信号量:
                Semaphore() acquire() release()
                通常将将信号量当成一种资源，例如我的计算机内存有限，但是有很多任务，每次只能执
                行5个，就可以设置五个信号量，执行一个消耗一个信号量，执行完，归还信号量，
                当没有信号量，就阻塞等待

        2 threading 创建线程:
            Thread() 创建线程
            start() 启动线程
            join() 回收线程
            注: (在线程中调用exit()退出进程，整个进程都会退出)(线程共享进程的内存空间)

        3 线程属性:
            name, is_alive(), daemon

        4 自定义线程类:
            继承Thread 重写__init__和 run方法
            注: 也可以自定义进程类，就是继承Process

        5 线程的同步互斥:
            (其实就是人为的加阻塞)
            同步互斥方法:
                Event(), wait(), set(), clear()
                Lock(), acquire(), release()

            死锁:
                由于上锁造成的程序阻塞 (交换人质，都不肯先放人，两边都阻塞了)

                
"""