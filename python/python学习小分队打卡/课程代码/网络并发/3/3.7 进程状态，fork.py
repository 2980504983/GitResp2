"""
    进程状态
        三态:
            就绪态: 进程具备执行条件，等待分配cpu资源
            运行态: 进程占有cpu时间片正在运行
            阻塞/等待态: 进程暂时停止运行，让出cpu

        五态:
            新建: 创建一个进程，获取资源的过程，新建后面是就绪
            终止: 进程结束，释放资源的过程，终止前面是执行
            详细见 进程五态.jpg

        状态查看命令: ps -aux --> STAT列就是进程的状态
        (S等待态， R执行态， D等待态， T等待态， Z僵尸， +前台进程， l有多线程...)

    进程的运行特征:
        1 进程可以使用计算机多核资源
        2 进程是计算机分配资源的最小单位 (其实线程比进程还小，但是计算机会将资源分配给进程，再由进程来分配资源给线程)
        3 进程之间的运行互不影响，各自独立
        4 每个进程拥有独立的空间，各自使用自己空间资源

    基于fork的多进程编程
        windows没有fork，要执行fork需要在linux环境下

        fork使用:
            pid = os.fork()
"""

import os

# 创建子进程
# 创建一个进程，并得到创建进程的pid号，但是被创建的进程，并不会在执行创建进程的命令，
# 会得到一个没有意义的0(pid=0,但是哪个零没有意义，这也是为什么进程的pid是大于零的整数)
pid = os.fork()

if pid < 0:
    print("Create process failed")  # 上面的操作也有可能创建进程失败，但是很少见，失败会返回一个负数

# 子进程执行部分
elif pid == 0:
    print("The new process")

# 父进程执行部分
else:
    print("The old process")

# 父子进程都会执行
print("Fork test over")

# 这段代码会产生两个进程，在代码执行时，fork会执行产生一个进程，(此时有两个进程，程序本身为父进程，
# fork创建的为子进程) 并返回产生进程(子进程)的pid，注意子进程中的fork并不会在产生进程，而是会返回
# 一个无意义的零。还有一点就是，父进程和子进程同时运行，但是执行的先后顺序是不一定的，都在争夺cpu时间片
# 详细见 创建进程.jpg

# ------------------------------------------------------------------

# 创建的子进程会复制父进程的内存空间，每个进程拥有独立的空间，各自使用自己空间资源

from time import sleep
print('====================================')  # 这个子进程并不会执行
a = 1  # 这是赋值语句会开辟内存空间，上面的只是打印

pid = os.fork()
if pid < 0:
    print("Create process failed")

elif pid == 0:
    print("The new process")
    print('a:', a)  # 虽然子进程又有执行a = 1，但是会复制父进程的内存空间，因此可以打印出a:1
    a = 10000  # 因为是拷贝内存空间，所以父子进程各有一个a变量，这里只是修改子进程中的a变量

else:
    sleep(1)  # sleep1秒让子进程先执行
    print("The old process")
    print("a:", a)  # 父进程的a并没有被修改，结果为 a:1

print('All a->', a)  # 父子进程都会执行

# 详细见 父子进程的内存.jpg

# -----------------------------------------------------------------------

# 两段代码总结:
# 1 子进程会复制父进程的全部内存空间，从fork下一局开始执行
# 2 父子进程各自独立运行，运行顺序不一定
# 3 利用父子进程fork返回值区别，配合if结构让父子进程执行不同内容，几乎是固定搭配
# 4 父子进程由各自特有特征，比如PID，PCB命令集
# 5 父进程fork之前开辟的空间子进程同样拥有，父子进城对各自空间的操作不会相互影响
