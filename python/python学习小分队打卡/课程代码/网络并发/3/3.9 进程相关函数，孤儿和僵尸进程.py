"""
    进程相关函数
        1 os.getpid():
            获取一个进程的pid值，返回当前进程的pid
        2 os.getppid():
            获取父进程的pid值，返回父进程pid
        3 os._exit(status):
            结束一个进程，参数表示进程的终止状态(虽然输入什么对函数都没有影响，但是规定输入0表示
            正常退出，1表示什么什么)
        4 sys.exit([status]):
            退出进程，参数可选，传一个字符串 表示退出时打印的内容

        # 父子进程的退出是互不影响的，谁退出都不会影响另一个

    孤儿进程:
        某个进程的父进程已经结束了，此时这个进程就会变成孤儿进程，孤儿进程会被操作系统派出的专有
        进程收养，这个专有进程就会成为孤儿进程新的父进程。只有操作系统重启动后，专有进程的pid才会变
        特点:
            孤儿进程退出，专有进程会自动处理，所以孤儿进程不会变成僵尸进程

    僵尸进程:
        子进程先与父进程退出，父进程又没有处理子进程的退出状态，此时子进程就会称为僵尸进程,当然
        只要父进程退出了，系统就会处理这些僵尸进程
        特点:
            僵尸进程虽然结束，但是仍会存留部分pcb信息在内存中，大量的僵尸进程会浪费系统的内存资源
            (服务器，如果经常不重启就容易产生很多僵尸进程)
        如何避免:
            1 用wait函数处理子进程退出:
                pid, status = os.wait()
                在父进程中阻塞等待子进程退出，返回值: pid 退出子进程的pid，status 子进程退出状态

            2 创建二级子进程处理僵尸
                1 父进程创建子进程,并wait等待以及子进程退出(虽然也要wait，但是子进程并不干活，
                  仅仅是创建二级子进程就关闭，所以不会占用很多时间，)
                2 子进程创建在创建一个子进程(创建二级子进程)，然后退出
                3 让二级子进程来完成原来子进程的任务，因为子进程已经退出，所以二级子进程是孤儿进程
                  不会变成僵尸

            3 通过信号处理子进程退出
                原理:
                    子进程退出时会发送信号给父进程，如果父进程忽略子进程信号，则系统就会自动
                    处理子进程退出
                方法:
                    使用signal模块在父进程创建子进程前写如下语句:
                        import signal
                        signal.signal(signal.SIGCHLD, signal.SIG_IGN)
                特点:
                    非阻塞，不会影响父进程运行，调用一次，就可以处理所有子进程退出，以后这个
                    父进程的子进程退出就都由操作系统处理了
                (终极版本)





"""
