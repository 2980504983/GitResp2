"""
    常数操作:
        与数据量无关的操作，例如，加减乘除，注意这里的数据量是根据具体的情景来定的，变量不一定就是数据量
    时间复杂度:
        就是先列出常数操作表达式，并且只保留高阶项，并且舍去高阶项系数，O(n2)

        评价一个算法流程的好坏，先看时间复杂度的指标，如果一样就要看通过在相同样本下的实验进行
        比较，不能通过常数表达式来比较，因为(假如10a， 5a，a表示数据量，10和5表示常数操作的
        次数，但是并不能说10a 就一定比5a慢，因为有可能这个10表示十个5想乘，而另一个则是5个十个
        5想乘)
        所以当时间复杂度相同就要通过实际实验来比较快慢

    额外空间复杂度:
        开辟的空间与数据量无关，就是1，例如只定义了几个变量。但是如果数据量有关，例如你需要开辟
        一个与数据量相同的数组，就是O(n)读作big O n

    选择排序:
        两次遍历数组，寻找每个位置上的最小值，外层循环确定位置，内层循环确定最小值。
        时间复杂度O(n2) 不在创建数组的话, 空间复杂度就是O(1)

    冒泡排序:
        两次遍历数组，数值两两比较，大的排在小的后面，第一次外层循环将最大值放在最后的位置上，
        外层循环同样是确定位置，内层循环确定最大值，相当于从后往前不断确定最大值
        时间复杂度O(n2) 在不创建数组的情况下，空间复杂度就是O(1)

    两数位置交换操作:

        常规操作: a, b = b, a

        异或操作:
            异或性质:
                1 (相同为0, 不同为1)
                2 (n^0=n, n^n=0)
                3 (满足交换律，就是说一堆数要异或，谁先异或结果都一样)
            由此可以通过异或操作交换两数位置(异或操作更快)(但是不推荐这么写，容易出问题):
                a = a^b
                b = a^b  (b = a^b^b = a^0 = a)
                a = a^b  (a = a^b^a = b^0 = b) 注意: a不是a,是a^b
                这样两个数就交换过来了()
                注意: 这种操作必须保证a和b的内存空间不是一个，例如在一个数组中，我有两个指针
                分别就是a，b如果要用这种方法，那么必须保证两个指针不重合，重合，两个指针的
                指向的位置，数据就会变成零。

            异或操作经典例题:
                1 已知一个数组里面，有一个数出现了奇数次，其它数都出现了偶数次，求这个出现奇数
                  次的数:
                    题解:
                        a = 0
                        for item in nums:
                            a = a^item
                        return a
                    因为异或操作没有顺序，因此出现偶数次的数都会两两消掉，变成零，留下的一个
                    数就是哪个出现了奇数次的数

                2 已知一个数组里面，有两个数出现了奇数次，其它数都出现了偶数次，求这两个出现
                  奇数次的数:
                    思路: 设这两个出现奇数次的数字是a和b,eor = 0
                        1 遍历一边数组，全部异或一遍，就得到了eor= a^b
                        2 因为 a!=b(有两个数) 所以，eor!=0，eor有一位上是1，所以，这一位
                          a和b是不同的，要么a是1，b是0要么反过来
                        3 利用这个性质，我再去遍历一遍数组，并且只让哪一位上是1的数全部进行
                          异或操作，就得到了a或者b(因为数组中只有两种树，一种是哪一位是1的
                          一种是哪一位是0的，而a，b不是同一种，所以，问题就变成了上面哪个求一个
                          奇数的题目了)


                    题解:
                        eor = 0
                        for item in nums:
                        eor ^= item

                        # eor = a^b
                        # 有两个数，所以a!=b ，所以eor!=0
                        # 所以eor必然有一个位置上是1

                        rightone = eor &(~eor + 1)

                        # 提取最右的1
                        # 假设eor为 100010， ~eor表示eor的反码为: 011101
                        # 再加上1就等于 011110，咋把它和eor进行与操作(只有11为1，其它都为0):
                        # 得到 000010，这样就提取出了eor最右的1了

                        eor1 = 0
                        for item in nums:
                            if (item & rightone) == 0
                                eor1 ^= item

                        # 遍历数组，将数字与rightone进行与操作,如果结果等于0，就说明，这个
                          数字在rightone为1的哪一位上是0 (因为与操作只有11为1，rightone只有
                          一个1，也就意味着和另一个数与操作，其它位上都是0，如果rightone的
                          1对上0则结果就等于0了，如果是1结果就是rightone)
                        # 此时eor1=a或者b

                        return eor1, eor^eor1

    插入排序:
    （插入排序的时间复杂度和数据状况有关，但是最坏情况仍然是O(n2)）
        不断确定有序的数组片段，直到片段长度达到数组长度，两次循环，外层循环，表示有序数组片段
        的长度，内层循环则让有序数组片段的最后一个变量的下一个变量，依次向右比较，当大于比较的变量
        时就插入其中，有序数组片段的长度就加一

    二分法:
        在一个有序数组中寻找某个数，如果，直接遍历寻找，时间复杂度是O(n)
        而如果用二分法(每次取中间值并判断，并判断它与目标数的关系，从而排除一半的区域，然后接着，
        二分，直到找到数为止)，时间复杂度则是O(log2N) 如果底数是2 通常会省略写成O(logN)

        二分法还可以用来寻找小于等于一个数最右侧的位置，或者大于等于一个数最左侧的位置
            例如 在数组 [122222333344445555666] 中寻找小于等于3最右侧的位置：
                先二分，如果中间值小于等于3，用一个变量t记录它，在二分 如果中间值仍然小于等于3，
                就更新变量t，直到low>=high
        局部最小问题:
            有一个长度为n无序数组nums,满足相邻数一定不相等, 求数组中一个局部最小的数(局部最小: 就是一个数，
            比他两侧的数都要小，如果有一侧没有数，小于另一侧数就行)。
            首先先确定，0和n位置是否是局部最小值，如果是哪个是局部最小直接返回就行了，如果不是，
            说明1和n-1位置上的数一定比0和n的大，详细见局部最小问题.png

            由这个问题可以看出，并不一定要有序才能二分，当你可以依托某一个条件判断甩掉另一边时，就能
            二分


    对数器:
        测试一个算法正确与否的思想:
            首先搞出一个随机样本产生器，然后拿出你要测的算法，在拿出一个其它算法(官方的什么的都行)
            让这两个算法都经过随机样本产生器产生的样本的测试(样本数量什么的你自己搞当然越大越好)，
            (随机样本产生器搞不来就百度)，再将他们的结果进行比对，如果都一样就说明你要测试的算法
            没问题，如果出错了，要么你的算法错了，要么比对算法错了，要么两个都错了






"""